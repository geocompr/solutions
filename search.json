[{"path":"index.html","id":"welcome","chapter":"Welcome","heading":"Welcome","text":"website provides solutions exercises Geocomputation R, 2nd edition.Solutions first edition Geocomputation R can found https://geocompr.github.io/vignettes/.","code":""},{"path":"index.html","id":"license","chapter":"Welcome","heading":"License","text":"work licensed Creative Commons Attribution-NonCommercial-NoDerivatives 4.0 International License.","code":""},{"path":"intro.html","id":"intro","chapter":"1 Introduction","heading":"1 Introduction","text":"E1. Think terms ‘GIS’, ‘GDS’ ‘geocomputation’ described . () best describes work like using geo* methods software ?E2. Provide three reasons using scriptable language R geocomputation instead using graphical user interface (GUI) based GIS QGIS.E3. Name two advantages two disadvantages using mature vs recent packages geographic data analysis (example sp vs sf, raster vs terra).","code":""},{"path":"spatial-class.html","id":"spatial-class","chapter":"2 Geographic data in R","heading":"2 Geographic data in R","text":"E1. Use summary() geometry column world data object. output tell us :geometry type?number countries?coordinate reference system (CRS)?E2. Run code ‘generated’ map world Section 2.2.4 Base plot arguments.\nFind two similarities two differences image computer book.cex argument (see ?plot)?cex set sqrt(world$pop) / 10000?Bonus: experiment different ways visualize global population.E3. Use plot() create maps Nigeria context (see Section 2.2.4 Base plot arguments).Adjust lwd, col expandBB arguments plot().Challenge: read documentation text() annotate map.E4. Create empty SpatRaster object called my_raster 10 columns 10 rows.\nAssign random values 0 10 new raster plot .E5. Read-raster/nlcd.tif file spDataLarge package.\nkind information can get properties file?E6. Check CRS raster/nlcd.tif file spDataLarge package.\nkind information can learn ?WKT describes two-dimensional projected coordinate reference system.\nbased GRS 1980 ellipsoid North American Datum 1983 Greenwich prime meridian.\nused Transverse Mercator projection transform geographic projected CRS (UTM zone 12N).\nfirst axis related eastness, second one related northness, axes units meters.\nSRID CRS “EPSG:26912”.","code":"\nlibrary(sf)\n#> Linking to GEOS 3.8.0, GDAL 3.0.4, PROJ 6.3.1\nlibrary(spData)\nlibrary(terra)\n#> terra version 1.5.0\nsummary(world)\n#>     iso_a2           name_long          continent          region_un        \n#>  Length:177         Length:177         Length:177         Length:177        \n#>  Class :character   Class :character   Class :character   Class :character  \n#>  Mode  :character   Mode  :character   Mode  :character   Mode  :character  \n#>                                                                             \n#>                                                                             \n#>                                                                             \n#>                                                                             \n#>   subregion             type              area_km2             pop          \n#>  Length:177         Length:177         Min.   :    2417   Min.   :5.63e+04  \n#>  Class :character   Class :character   1st Qu.:   46185   1st Qu.:3.75e+06  \n#>  Mode  :character   Mode  :character   Median :  185004   Median :1.04e+07  \n#>                                        Mean   :  832558   Mean   :4.28e+07  \n#>                                        3rd Qu.:  621860   3rd Qu.:3.07e+07  \n#>                                        Max.   :17018507   Max.   :1.36e+09  \n#>                                                           NA's   :10        \n#>     lifeExp       gdpPercap                 geom    \n#>  Min.   :50.6   Min.   :   597   MULTIPOLYGON :177  \n#>  1st Qu.:65.0   1st Qu.:  3752   epsg:4326    :  0  \n#>  Median :72.9   Median : 10734   +proj=long...:  0  \n#>  Mean   :70.9   Mean   : 17106                      \n#>  3rd Qu.:76.8   3rd Qu.: 24233                      \n#>  Max.   :83.6   Max.   :120860                      \n#>  NA's   :10     NA's   :17\nmy_raster = rast(ncol = 10, nrow = 10,\n                 vals = sample(0:10, size = 10 * 10, replace = TRUE))\nplot(my_raster)\nnlcd = rast(system.file(\"raster/nlcd.tif\", package = \"spDataLarge\"))\ndim(nlcd) # dimensions\n#> [1] 1359 1073    1\nres(nlcd) # resolution\n#> [1] 31.5 31.5\next(nlcd) # extent\n#> SpatExtent : 301903.344386758, 335735.354381954, 4111244.46098842, 4154086.47216415 (xmin, xmax, ymin, ymax)\nnlyr(nlcd) # number of layers\n#> [1] 1\ncat(crs(nlcd)) # CRS\n#> PROJCRS[\"NAD83 / UTM zone 12N\",\n#>     BASEGEOGCRS[\"NAD83\",\n#>         DATUM[\"North American Datum 1983\",\n#>             ELLIPSOID[\"GRS 1980\",6378137,298.257222101,\n#>                 LENGTHUNIT[\"metre\",1]]],\n#>         PRIMEM[\"Greenwich\",0,\n#>             ANGLEUNIT[\"degree\",0.0174532925199433]],\n#>         ID[\"EPSG\",4269]],\n#>     CONVERSION[\"UTM zone 12N\",\n#>         METHOD[\"Transverse Mercator\",\n#>             ID[\"EPSG\",9807]],\n#>         PARAMETER[\"Latitude of natural origin\",0,\n#>             ANGLEUNIT[\"degree\",0.0174532925199433],\n#>             ID[\"EPSG\",8801]],\n#>         PARAMETER[\"Longitude of natural origin\",-111,\n#>             ANGLEUNIT[\"degree\",0.0174532925199433],\n#>             ID[\"EPSG\",8802]],\n#>         PARAMETER[\"Scale factor at natural origin\",0.9996,\n#>             SCALEUNIT[\"unity\",1],\n#>             ID[\"EPSG\",8805]],\n#>         PARAMETER[\"False easting\",500000,\n#>             LENGTHUNIT[\"metre\",1],\n#>             ID[\"EPSG\",8806]],\n#>         PARAMETER[\"False northing\",0,\n#>             LENGTHUNIT[\"metre\",1],\n#>             ID[\"EPSG\",8807]]],\n#>     CS[Cartesian,2],\n#>         AXIS[\"(E)\",east,\n#>             ORDER[1],\n#>             LENGTHUNIT[\"metre\",1]],\n#>         AXIS[\"(N)\",north,\n#>             ORDER[2],\n#>             LENGTHUNIT[\"metre\",1]],\n#>     USAGE[\n#>         SCOPE[\"unknown\"],\n#>         AREA[\"North America - 114°W to 108°W and NAD83 by country\"],\n#>         BBOX[31.33,-114,84,-108]],\n#>     ID[\"EPSG\",26912]]\ncat(crs(nlcd))\n#> PROJCRS[\"NAD83 / UTM zone 12N\",\n#>     BASEGEOGCRS[\"NAD83\",\n#>         DATUM[\"North American Datum 1983\",\n#>             ELLIPSOID[\"GRS 1980\",6378137,298.257222101,\n#>                 LENGTHUNIT[\"metre\",1]]],\n#>         PRIMEM[\"Greenwich\",0,\n#>             ANGLEUNIT[\"degree\",0.0174532925199433]],\n#>         ID[\"EPSG\",4269]],\n#>     CONVERSION[\"UTM zone 12N\",\n#>         METHOD[\"Transverse Mercator\",\n#>             ID[\"EPSG\",9807]],\n#>         PARAMETER[\"Latitude of natural origin\",0,\n#>             ANGLEUNIT[\"degree\",0.0174532925199433],\n#>             ID[\"EPSG\",8801]],\n#>         PARAMETER[\"Longitude of natural origin\",-111,\n#>             ANGLEUNIT[\"degree\",0.0174532925199433],\n#>             ID[\"EPSG\",8802]],\n#>         PARAMETER[\"Scale factor at natural origin\",0.9996,\n#>             SCALEUNIT[\"unity\",1],\n#>             ID[\"EPSG\",8805]],\n#>         PARAMETER[\"False easting\",500000,\n#>             LENGTHUNIT[\"metre\",1],\n#>             ID[\"EPSG\",8806]],\n#>         PARAMETER[\"False northing\",0,\n#>             LENGTHUNIT[\"metre\",1],\n#>             ID[\"EPSG\",8807]]],\n#>     CS[Cartesian,2],\n#>         AXIS[\"(E)\",east,\n#>             ORDER[1],\n#>             LENGTHUNIT[\"metre\",1]],\n#>         AXIS[\"(N)\",north,\n#>             ORDER[2],\n#>             LENGTHUNIT[\"metre\",1]],\n#>     USAGE[\n#>         SCOPE[\"unknown\"],\n#>         AREA[\"North America - 114°W to 108°W and NAD83 by country\"],\n#>         BBOX[31.33,-114,84,-108]],\n#>     ID[\"EPSG\",26912]]"},{"path":"attr.html","id":"attr","chapter":"3 Attribute data operations","heading":"3 Attribute data operations","text":"exercises use us_states us_states_df datasets spData package.\nmust attached package, packages used attribute operations chapter (sf, dplyr, terra) commands library(spData) attempting exercises:us_states spatial object (class sf), containing geometry attributes (including name, region, area, population) states within contiguous United States.\nus_states_df data frame (class data.frame) containing name additional variables (including median income poverty level, years 2010 2015) US states, including Alaska, Hawaii Puerto Rico.\ndata comes United States Census Bureau, documented ?us_states ?us_states_df.E1. Create new object called us_states_name contains NAME column us_states object using either base R ([) tidyverse (select()) syntax.\nclass new object makes geographic?E2. Select columns us_states object contain population data.\nObtain result using different command (bonus: try find three ways obtaining result).\nHint: try use helper functions, contains starts_with dplyr (see ?contains).E3. Find states following characteristics (bonus find plot ):Belong Midwest region.Belong West region, area 250,000 km2and 2015 population greater 5,000,000 residents (hint: may need use function units::set_units() .numeric()).Belong South region, area larger 150,000 km2 total population 2015 larger 7,000,000 residents.E4. total population 2015 us_states dataset?\nminimum maximum total population 2015?E5. many states region?E6. minimum maximum total population 2015 region?\ntotal population 2015 region?E7. Add variables us_states_df us_states, create new object called us_states_stats.\nfunction use ?\nvariable key datasets?\nclass new object?E8. us_states_df two rows us_states.\ncan find ? (hint: try use dplyr::anti_join() function)E9. population density 2015 state?\npopulation density 2010 state?E10. much population density changed 2010 2015 state?\nCalculate change percentages map .E11. Change columns’ names us_states lowercase. (Hint: helper functions - tolower() colnames() may help.)E12. Using us_states us_states_df create new object called us_states_sel.\nnew object two variables - median_income_15 geometry.\nChange name median_income_15 column Income.E13. Calculate change number residents living poverty level 2010 2015 state. (Hint: See ?us_states_df documentation poverty level columns.)\nBonus: Calculate change percentage residents living poverty level state.E14. minimum, average maximum state’s number people living poverty line 2015 region?\nBonus: region largest increase people living poverty line?E15. Create raster scratch nine rows columns resolution 0.5 decimal degrees (WGS84).\nFill random numbers.\nExtract values four corner cells.E16. common class example raster grain (hint: modal)?E17. Plot histogram boxplot dem.tif file spDataLarge package (system.file(\"raster/dem.tif\", package = \"spDataLarge\")).","code":"\nlibrary(sf)\n#> Linking to GEOS 3.8.0, GDAL 3.0.4, PROJ 6.3.1\nlibrary(dplyr)\n#> \n#> Attaching package: 'dplyr'\n#> The following objects are masked from 'package:stats':\n#> \n#>     filter, lag\n#> The following objects are masked from 'package:base':\n#> \n#>     intersect, setdiff, setequal, union\nlibrary(terra)\n#> terra version 1.5.0\n#> \n#> Attaching package: 'terra'\n#> The following object is masked from 'package:dplyr':\n#> \n#>     src\nlibrary(spData)\ndata(us_states)\ndata(us_states_df)\nus_states_name = us_states[\"NAME\"]\nclass(us_states_name)\n#> [1] \"sf\"         \"data.frame\"\nr = rast(nrow = 9, ncol = 9, res = 0.5,\n         xmin = 0, xmax = 4.5, ymin = 0, ymax = 4.5,\n         vals = rnorm(81))\n# using cell IDs\nr[c(1, 9, 81 - 9 + 1, 81)]\n#>    lyr.1\n#> 1  1.434\n#> 2 -0.265\n#> 3 -0.587\n#> 4 -2.593\nr[c(1, nrow(r)), c(1, ncol(r))]\n#>    lyr.1\n#> 1  1.434\n#> 2 -0.265\n#> 3 -0.587\n#> 4 -2.593\ngrain = rast(system.file(\"raster/grain.tif\", package = \"spData\"))\nglobal(grain, fun = modal) #only one value is shown when there are ties\n#>       global\n#> grain      1\nfreq(grain) #the most common classes are silt and sand (13 cells)\n#>   layer value count label\n#> 1     1     0    10  clay\n#> 2     1     1    13  silt\n#> 3     1     2    13  sand\ndem = rast(system.file(\"raster/dem.tif\", package = \"spDataLarge\"))\nhist(dem)\nboxplot(dem)\n\n# we can also use ggplot2 after converting SpatRaster to a data frame\nlibrary(ggplot2)\nggplot(as.data.frame(dem), aes(dem)) + geom_histogram()\n#> `stat_bin()` using `bins = 30`. Pick better value with `binwidth`.\nggplot(as.data.frame(dem), aes(dem)) + geom_boxplot()"},{"path":"spatial-operations.html","id":"spatial-operations","chapter":"4 Spatial data operations","heading":"4 Spatial data operations","text":"E1. established Section ?? Canterbury region New Zealand containing 100 highest points country.\nmany high points Canterbury region contain?E2. region second highest number nz_height points , many ?E3. Generalizing question regions: many New Zealand’s 16 regions contain points belong top 100 highest points country? regions?Bonus: create table listing regions order number points name.E4. Use dem = rast(system.file(\"raster/dem.tif\", package = \"spDataLarge\")), reclassify elevation three classes: low (<300), medium high (>500).\nSecondly, read NDVI raster (ndvi = rast(system.file(\"raster/ndvi.tif\", package = \"spDataLarge\"))) compute mean NDVI mean elevation altitudinal class.E5. Apply line detection filter rast(system.file(\"ex/logo.tif\", package = \"terra\")).\nPlot result.\nHint: Read ?terra::focal().E6. Calculate Normalized Difference Water Index (NDWI; (green - nir)/(green + nir)) Landsat image.\nUse Landsat image provided spDataLarge package (system.file(\"raster/landsat.tif\", package = \"spDataLarge\")).\nAlso, calculate correlation NDVI NDWI area.","code":"\nlibrary(sf)\n#> Linking to GEOS 3.8.0, GDAL 3.0.4, PROJ 6.3.1\nlibrary(dplyr)\n#> \n#> Attaching package: 'dplyr'\n#> The following objects are masked from 'package:stats':\n#> \n#>     filter, lag\n#> The following objects are masked from 'package:base':\n#> \n#>     intersect, setdiff, setequal, union\ndata(nz, package = \"spData\")\ndata(nz_height, package = \"spData\")\nlibrary(tmap)\ntmap_mode(\"view\")\nqtm(nz) + qtm(nz_height)\ncanterbury = nz %>% filter(Name == \"Canterbury\")\ncanterbury_height = nz_height[canterbury, ]\nnrow(canterbury_height) # answer: 70\nnz_height_count = aggregate(nz_height, nz, length)\nnz_height_combined = cbind(nz, count = nz_height_count$elevation)\nnz_height_combined %>% \n  st_drop_geometry() %>% \n  dplyr::select(Name, count) %>% \n  arrange(desc(count)) %>% \n  slice(2)\n#>         Name count\n#> 1 West Coast    22\nnz_height_count = aggregate(nz_height, nz, length)\nnz_height_combined = cbind(nz, count = nz_height_count$elevation)\nnz_height_combined %>% \n  st_drop_geometry() %>% \n  dplyr::select(Name, count) %>% \n  arrange(desc(count)) %>% \n  na.omit()\n#>                Name count\n#> 1        Canterbury    70\n#> 2        West Coast    22\n#> 3           Waikato     3\n#> 4 Manawatu-Wanganui     2\n#> 5             Otago     2\n#> 6         Southland     1\n#> 7       Marlborough     1\nlibrary(terra)\n#> terra version 1.5.0\n#> \n#> Attaching package: 'terra'\n#> The following object is masked from 'package:dplyr':\n#> \n#>     src\ndem = rast(system.file(\"raster/dem.tif\", package = \"spDataLarge\"))\nndvi = rast(system.file(\"raster/ndvi.tif\", package = \"spDataLarge\"))\n\n#1\ndem_rcl = matrix(c(-Inf, 300, 0, 300, 500, 1, 500, Inf, 2), ncol = 3, byrow = TRUE)\ndem_reclass = classify(dem, dem_rcl)\nlevels(dem_reclass) = c(\"low\", \"medium\", \"high\")\nplot(dem_reclass)\n\n#2\nzonal(c(dem, ndvi), dem_reclass, fun = \"mean\")\n#>      dem dem   ndvi\n#> 1    low 274 -0.363\n#> 2 medium 392 -0.289\n#> 3   high 765 -0.208\n# from the focal help page (?terra::focal()):\n# Laplacian filter: filter=matrix(c(0,1,0,1,-4,1,0,1,0), nrow=3)\n# Sobel filters (for edge detection): \n# fx=matrix(c(-1,-2,-1,0,0,0,1,2,1), nrow=3) \n# fy=matrix(c(1,0,-1,2,0,-2,1,0,-1), nrow=3)\n\n# just retrieve the first channel of the R logo\nr = rast(system.file(\"ex/logo.tif\", package = \"terra\"))\n# compute the Sobel filter\nfilter_x = matrix(c(-1, -2, -1, 0, 0, 0, 1, 2, 1), nrow = 3)\nsobel_x = focal(r, w = filter_x)\nplot(sobel_x, col = c(\"white\", \"black\"))\n\nfilter_y = matrix(c(1, 0, -1, 2, 0, -2, 1, 0, -1), nrow = 3)\nsobel_y = focal(r, w = filter_y)\nplot(sobel_y, col = c(\"black\", \"white\"))\nfile = system.file(\"raster/landsat.tif\", package = \"spDataLarge\")\nmulti_rast = rast(file)\n\nndvi_fun = function(nir, red){\n  (nir - red) / (nir + red)\n}\nndvi_rast = lapp(multi_rast[[c(4, 3)]], fun = ndvi_fun)\nplot(ndvi_rast)\n\nndwi_fun = function(green, nir){\n    (green - nir) / (green + nir)\n}\n\nndwi_rast = lapp(multi_rast[[c(2, 4)]], fun = ndwi_fun)\nplot(ndwi_rast)\n\ntwo_rasts = c(ndvi_rast, ndwi_rast)\nnames(two_rasts) = c(\"ndvi\", \"ndwi\")\ntwo_rasts_df = as.data.frame(two_rasts)\ncor(two_rasts_df$ndvi, two_rasts_df$ndwi)\n#> [1] -0.913"},{"path":"geometric-operations.html","id":"geometric-operations","chapter":"5 Geometry operations","heading":"5 Geometry operations","text":"exercises use vector (zion_points) raster dataset (srtm) spDataLarge package.\nalso use polygonal ‘convex hull’ derived vector dataset (ch) represent area interest:E1. Generate plot simplified versions nz dataset.\nExperiment different values keep (ranging 0.5 0.00005) ms_simplify() dTolerance (100 100,000) st_simplify().value form result start break method, making New Zealand unrecognizable?Advanced: different geometry type results st_simplify() compared geometry type ms_simplify()? problems create can resolved?E2. first exercise Chapter Spatial data operations established Canterbury region 70 101 highest points New Zealand.\nUsing st_buffer(), many points nz_height within 100 km Canterbury?E3. Find geographic centroid New Zealand.\nfar geographic centroid Canterbury?E4. world maps north-orientation.\nworld map south-orientation created reflection (one affine transformations mentioned chapter) world object’s geometry.\nWrite code .\nHint: need use two-element vector transformation.\nBonus: create upside-map country.E5. Subset point p contained within x y.Using base subsetting operators.Using intermediary object created st_intersection().E6. Calculate length boundary lines US states meters.\nstate longest border shortest?\nHint: st_length function computes length LINESTRING MULTILINESTRING geometry.E7. Crop srtm raster using (1) zion_points dataset (2) ch dataset.\ndifferences output maps?\nNext, mask srtm using two datasets.\nCan see difference now?\ncan explain ?E8. Firstly, extract values srtm points represented zion_points.\nNext, extract average values srtm using 90 buffer around point zion_points compare two sets values.\nextracting values buffers suitable points alone?E9. Subset points higher 3100 meters New Zealand (nz_height object) create template raster resolution 3 km extent new point dataset.\nUsing two new objects:Count numbers highest points grid cell.Find maximum elevation grid cell.E10. Aggregate raster counting high points New Zealand (created previous exercise), reduce geographic resolution half (cells 6 6 km) plot result.Resample lower resolution raster back original resolution 3 km. results changed?Name two advantages disadvantages reducing raster resolution.Advantages:lower memory usefaster processinggood viz casesDisadvantages:removes geographic detailadds another processing stepE11. Polygonize grain dataset filter squares representing clay.Name two advantages disadvantages vector data raster data.useful convert rasters vectors work?Advantages:can used subset vector objectscan affine transformations use sf/dplyr verbsDisadvantages:better consistencyfast processing operationsfunctions developed domains","code":"#> Linking to GEOS 3.8.0, GDAL 3.0.4, PROJ 6.3.1\n#> terra version 1.5.0\nlibrary(sf)\nlibrary(terra)\nlibrary(spData)\nzion_points = read_sf(system.file(\"vector/zion_points.gpkg\", package = \"spDataLarge\"))\nsrtm = rast(system.file(\"raster/srtm.tif\", package = \"spDataLarge\"))\nch = st_combine(zion_points) %>%\n  st_convex_hull() %>% \n  st_as_sf()\nplot(rmapshaper::ms_simplify(st_geometry(nz), keep = 0.5))\nplot(rmapshaper::ms_simplify(st_geometry(nz), keep = 0.05))\n# Starts to breakdown here at 0.5% of the points:\nplot(rmapshaper::ms_simplify(st_geometry(nz), keep = 0.005))\n# At this point no further simplification changes the result\nplot(rmapshaper::ms_simplify(st_geometry(nz), keep = 0.0005))\nplot(rmapshaper::ms_simplify(st_geometry(nz), keep = 0.00005))\nplot(st_simplify(st_geometry(nz), dTolerance = 100))\nplot(st_simplify(st_geometry(nz), dTolerance = 1000))\n# Starts to breakdown at 10 km:\nplot(st_simplify(st_geometry(nz), dTolerance = 10000))\nplot(st_simplify(st_geometry(nz), dTolerance = 100000))\nplot(st_simplify(st_geometry(nz), dTolerance = 100000, preserveTopology = TRUE))\n\n# Problem: st_simplify returns POLYGON and MULTIPOLYGON results, affecting plotting\n# Cast into a single geometry type to resolve this\nnz_simple_poly = st_simplify(st_geometry(nz), dTolerance = 10000) %>% \n  st_sfc() %>% \n  st_cast(\"POLYGON\")\nnz_simple_multipoly = st_simplify(st_geometry(nz), dTolerance = 10000) %>% \n  st_sfc() %>% \n  st_cast(\"MULTIPOLYGON\")\nplot(nz_simple_poly)\nlength(nz_simple_poly)\nnrow(nz)\ncanterbury = nz[nz$Name == \"Canterbury\", ]\ncant_buff = st_buffer(canterbury, 100)\nnz_height_near_cant = nz_height[cant_buff, ]\nnrow(nz_height_near_cant) # 75 - 5 more\ncant_cent = st_centroid(canterbury)\nnz_centre = st_centroid(st_union(nz))\nst_distance(cant_cent, nz_centre) # 234 km\nworld_sfc = st_geometry(world)\nworld_sfc_mirror = world_sfc * c(1, -1)\nplot(world_sfc)\nplot(world_sfc_mirror)\n\nus_states_sfc = st_geometry(us_states)\nus_states_sfc_mirror = us_states_sfc * c(1, -1)\nplot(us_states_sfc)\nplot(us_states_sfc_mirror)\n## nicer plot\nlibrary(ggrepel)\nus_states_sfc_mirror_labels = st_centroid(us_states_sfc_mirror) %>% \n  st_coordinates() %>%\n  as_data_frame() %>% \n  mutate(name = us_states$NAME)\nus_states_sfc_mirror_sf = st_set_geometry(us_states, us_states_sfc_mirror)\nggplot(data = us_states_sfc_mirror_sf) +\n  geom_sf(color = \"white\") +\n  geom_text_repel(data = us_states_sfc_mirror_labels, mapping = aes(X, Y, label = name), size = 3, min.segment.length = 0) +\n  theme_void() \np_in_y = p[y]\np_in_xy = p_in_y[x]\nx_and_y = st_intersection(x, y)\np[x_and_y]\nus_states2163 = st_transform(us_states, \"EPSG:2163\")\nus_states_bor = st_cast(us_states2163, \"MULTILINESTRING\")\nus_states_bor$borders = st_length(us_states_bor)\narrange(us_states_bor, borders)\narrange(us_states_bor, -borders)\nplot(srtm)\nplot(st_geometry(zion_points), add = TRUE)\nplot(ch, add = TRUE)\n\nsrtm_crop1 = crop(srtm, vect(zion_points))\nsrtm_crop2 = crop(srtm, vect(ch))\nplot(srtm_crop1)\nplot(srtm_crop2)\n\nsrtm_mask1 = mask(srtm, vect(zion_points))\nsrtm_mask2 = mask(srtm, vect(ch))\nplot(srtm_mask1)\nplot(srtm_mask2)\nzion_points_buf = st_buffer(zion_points, dist = 90)\nplot(srtm)\nplot(st_geometry(zion_points_buf), add = TRUE)\nplot(ch, add = TRUE)\n\nzion_points_points = extract(srtm, vect(zion_points))\nzion_points_buf = extract(srtm, vect(zion_points_buf))\nplot(zion_points_points$srtm, zion_points_buf$srtm2)\nnz_height3100 = dplyr::filter(nz_height, elevation > 3100)\nnew_graticule = st_graticule(nz_height3100, datum = \"EPSG:2193\")\nplot(st_geometry(nz_height3100), graticule = new_graticule, axes = TRUE)\n\nnz_template = rast(ext(nz_height3100), resolution = 3000, crs = crs(nz_height3100))\n\nnz_raster = rasterize(vect(nz_height3100), nz_template, \n                       field = \"elevation\", fun = \"length\")\nplot(nz_raster)\nplot(st_geometry(nz_height3100), add = TRUE)\n\nnz_raster2 = rasterize(vect(nz_height3100), nz_template, \n                       field = \"elevation\", fun = max)\nplot(nz_raster2)\nplot(st_geometry(nz_height3100), add = TRUE)\nnz_raster_low = raster::aggregate(nz_raster, fact = 2, fun = sum, na.rm = TRUE)\nres(nz_raster_low)\n#> [1] 6000 6000\n\nnz_resample = resample(nz_raster_low, nz_raster)\nplot(nz_raster_low)\nplot(nz_resample) # the results are spread over a greater area and there are border issues\nplot(nz_raster)\ngrain = rast(system.file(\"raster/grain.tif\", package = \"spData\"))\ngrain_poly = as.polygons(grain) %>% \n  st_as_sf()\nlevels(grain)\n#> [[1]]\n#> [1] \"clay\" \"silt\" \"sand\"\nclay = dplyr::filter(grain_poly, grain == \"clay\")\nplot(clay)"},{"path":"reproj-geo-data.html","id":"reproj-geo-data","chapter":"6 Reprojecting geographic data","heading":"6 Reprojecting geographic data","text":"E1. Create new object called nz_wgs transforming nz object WGS84 CRS.Create object class crs use query CRSs.reference bounding box object, units CRS use?Remove CRS nz_wgs plot result: wrong map New Zealand ?E2. Transform world dataset transverse Mercator projection (\"+proj=tmerc\") plot result.\nchanged ?\nTry transform back WGS 84 plot new object.\nnew object differ original one?E3. Transform continuous raster (con_raster) NAD83 / UTM zone 12N using nearest neighbor interpolation method.\nchanged?\ninfluence results?E4. Transform categorical raster (cat_raster) WGS 84 using bilinear interpolation method.\nchanged?\ninfluence results?","code":"\nlibrary(terra)\n#> terra version 1.5.0\nst_crs(nz)\nnz_wgs = st_transform(nz, \"EPSG:4326\")\nnz_crs = st_crs(nz)\nnz_wgs_crs = st_crs(nz_wgs)\nnz_crs$epsg\nnz_wgs_crs$epsg\nst_bbox(nz)\nst_bbox(nz_wgs)\nnz_wgs_NULL_crs = st_set_crs(nz_wgs, NA)\nnz_27700 = st_transform(nz_wgs, \"EPSG:27700\")\npar(mfrow = c(1, 3))\nplot(st_geometry(nz))\nplot(st_geometry(nz_wgs))\nplot(st_geometry(nz_wgs_NULL_crs))\n# answer: it is fatter in the East-West direction\n# because New Zealand is close to the South Pole and meridians converge there\nplot(st_geometry(nz_27700))\npar(mfrow = c(1, 1))\n# see https://github.com/r-spatial/sf/issues/509\nworld_tmerc = st_transform(world, \"+proj=tmerc\")\nplot(st_geometry(world_tmerc))\nworld_4326 = st_transform(world_tmerc, \"EPSG:4326\")\nplot(st_geometry(world_4326))\ncon_raster = rast(system.file(\"raster/srtm.tif\", package = \"spDataLarge\"))\ncon_raster_utm12n = project(con_raster, \"EPSG:32612\", method = \"near\")\ncon_raster_utm12n\n#> class       : SpatRaster \n#> dimensions  : 515, 422, 1  (nrow, ncol, nlyr)\n#> resolution  : 83.5, 83.5  (x, y)\n#> extent      : 301062, 336313, 4111111, 4154131  (xmin, xmax, ymin, ymax)\n#> coord. ref. : WGS 84 / UTM zone 12N (EPSG:32612) \n#> source      : memory \n#> name        : srtm \n#> min value   : 1024 \n#> max value   : 2892\n\nplot(con_raster)\nplot(con_raster_utm12n)\ncat_raster = rast(system.file(\"raster/nlcd.tif\", package = \"spDataLarge\"))\ncat_raster_wgs84 = project(cat_raster, \"EPSG:4326\", method = \"bilinear\")\ncat_raster_wgs84\n#> class       : SpatRaster \n#> dimensions  : 1246, 1244, 1  (nrow, ncol, nlyr)\n#> resolution  : 0.000315, 0.000315  (x, y)\n#> extent      : -113, -113, 37.1, 37.5  (xmin, xmax, ymin, ymax)\n#> coord. ref. : lon/lat WGS 84 (EPSG:4326) \n#> source      : memory \n#> name        : levels \n#> min value   :      1 \n#> max value   :      8\n\nplot(cat_raster)\nplot(cat_raster_wgs84)"},{"path":"read-write.html","id":"read-write","chapter":"7 Geographic data I/O","heading":"7 Geographic data I/O","text":"E1. List describe three types vector, raster, geodatabase formats.E2. Name least two differences read_sf() well-known function st_read().E3. Read cycle_hire_xy.csv file spData package spatial object (Hint: located misc\\ folder).\ngeometry type loaded object?E4. Download borders Germany using rnaturalearth, create new object called germany_borders.\nWrite new object file GeoPackage format.E5. Download global monthly minimum temperature spatial resolution five minutes using geodata package.\nExtract June values, save file named tmin_june.tif file (hint: use terra::subset()).E6. Create static map Germany’s borders, save PNG file.E7. Create interactive map using data cycle_hire_xy.csv file.\nExport map file called cycle_hire.html.","code":"\nlibrary(geodata)\n#> Loading required package: terra\n#> terra version 1.5.0\ngmmt = worldclim_global(var = \"tmin\", res = 5, path = tempdir())\nnames(gmmt)\n#>  [1] \"wc2.1_5m_tmin_01\" \"wc2.1_5m_tmin_02\" \"wc2.1_5m_tmin_03\" \"wc2.1_5m_tmin_04\"\n#>  [5] \"wc2.1_5m_tmin_05\" \"wc2.1_5m_tmin_06\" \"wc2.1_5m_tmin_07\" \"wc2.1_5m_tmin_08\"\n#>  [9] \"wc2.1_5m_tmin_09\" \"wc2.1_5m_tmin_10\" \"wc2.1_5m_tmin_11\" \"wc2.1_5m_tmin_12\"\nplot(gmmt)\n\ngmmt_june = terra::subset(gmmt, \"wc2.1_5m_tmin_06\")\nplot(gmmt_june)\nwriteRaster(gmmt_june, \"tmin_june.tif\")"},{"path":"adv-map.html","id":"adv-map","chapter":"8 Making maps with R","heading":"8 Making maps with R","text":"","code":""},{"path":"gis.html","id":"gis","chapter":"9 Bridges to GIS software","heading":"9 Bridges to GIS software","text":"","code":""},{"path":"algorithms.html","id":"algorithms","chapter":"10 Scripts, algorithms and functions","heading":"10 Scripts, algorithms and functions","text":"","code":""},{"path":"spatial-cv.html","id":"spatial-cv","chapter":"11 Statistical learning","heading":"11 Statistical learning","text":"","code":""},{"path":"transport.html","id":"transport","chapter":"12 Transportation","heading":"12 Transportation","text":"","code":""},{"path":"location.html","id":"location","chapter":"13 Geomarketing","heading":"13 Geomarketing","text":"","code":""},{"path":"eco.html","id":"eco","chapter":"14 Ecology","heading":"14 Ecology","text":"","code":""},{"path":"conclusion.html","id":"conclusion","chapter":"15 Conclusion","heading":"15 Conclusion","text":"","code":""}]
